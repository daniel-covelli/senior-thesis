# -*- coding: utf-8 -*-
"""demo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/daniel-covelli/d1201ff9e42e4ab39ef184b3cc10f091/demo.ipynb
"""

import json
import itertools
import operator
import time
import pandas as pd
import numpy as np
from pprint import pprint
from youtube_api import YouTubeDataAPI
from random import randint

import config

""" 
Title: Recfluence
Author: Ledwich, Mark
Date: 2020
Availability: https://github.com/markledwich2/Recfluence 
"""
classifications = pd.read_csv(
    '/Users/danielcovelli/Desktop/ISF190/recfluence_shared_data/channel_review.csv')
classifications.head()


def split(string):
    """
    @param: list
    @return: list with elements split on '|'
    """
    if string is np.nan:
        return []
    else:
        val = string.split("|")
        return val


classifications["REVIEWER_TAGS_LST"] = classifications['REVIEWER_TAGS'].apply(
    split)


class Starter:
    """
    Used to return a list of videos based on search query and video category
    """
    api_key = config.api_key
    yt = YouTubeDataAPI(api_key)

    def __init__(self, query, category, max_results=5):
        self.query = query
        self.category = category
        self.max_results = max_results

    def find_video(self):
        """
        Takes in query and returns a dictionary of result(s)
        """
        response = self.yt.search(
            q=self.query, max_results=self.max_results, topic_id=self.category)
        return response

    def get_arb(self):
        """
        Returns arbitrary video id
        Used for debugging

        @return: a video id from start
        """
        return self.start[0]


class Bot:
    api_key = config.api_key
    yt = YouTubeDataAPI(api_key)
    origin = 'start'
    itteration = 0
    weight_dict = {0: "Neutral", 1: "Right", -
                   1: "Left", 2: "Far Right", -2: "Far Left"}
    classif_dict = {"Mainstream News": 0, "PartisanLeft": -1, "PartisanRight": 2, "Conspiracy": 3, 'AntiSJW': 5, "StateFunded": 0, "AntiTheist": -5, "ReligiousConservative": 3, "Socialist": -6, "SocialJustice": -3, "MRA": 0,
                    "QAnon": 7, "Black": -4, "WhiteIdentitarian": 7, "Educational": 0, "Libertarian": 2, "LateNightTalkShow": -2, "Provocateur": 5, "Politician": 0, "JudeoChristianConservative": 3, 'AntiWhiteness': -4, "Revolutionary": -5}

    def __init__(self, bias, rounds, recomms):
        self.bias = bias
        self.rounds = rounds
        self.recomms = recomms

    def set_start(self, start):
        """
        Sets starting point for walk

        @param: list of videos
        """
        self.start = start
        self.start_length = len(start)

    def get_recommends(self, video):
        """
        @param: video
        @return: several recommendations
        """
        _id = video['video_id']
        response = self.yt.get_recommended_videos(
            _id, max_results=self.recomms)
        return response

    def get_meta(self, video):
        """
        @param: video
        @return: meta data for video
        """
        _id = video['video_id']
        response = self.yt.get_video_metadata(_id)
        return response

    def walk(self):
        """
        1. Classifies and picks from starting videos
        2. Appends results to videos list
        3. Requests recommendation based on the selected video
        4. Classifies and picks from recommended videos
        5. Appends results to videos list
        6. Repeat steps 3 and 5, N times

        @return: returns dictionary of results from step 3 through 5 
        """
        videos = []
        classified = self.get_classif(self.start)
        pick = self.pick(classified)
        videos = videos + classified
        self.itteration += 1
        for i in range(self.rounds):
            recommendations = self.get_recommends(pick)
            classified = self.get_classif(recommendations)
            pick = self.pick(classified)
            videos = videos + classified
            self.itteration += 1
        self.itteration = 0
        self.origin = 'start'
        return videos

    def get_classif(self, videos):
        """
        Gets video classifications from Recfluence dataset

        @param: list of videos
        @return: list of classified videos

        @source: https://www.educative.io/edpresso/how-to-flatten-a-list-of-lists-in-python
        """
        results = []
        for vid in videos:
            classifs = classifications.loc[classifications.CHANNEL_ID ==
                                           vid["channel_id"], 'REVIEWER_TAGS_LST']
            if classifs.empty or list(classifs)[0] == []:
                classifs_flat = ['None']
                weight = 0.0
                classif = 'Neutral'
            else:
                classifs_flat = list(itertools.chain(*classifs.values))
                weight = self.get_mean_weight(classifs_flat)
                if round(weight) > 2:
                    r_weight = 2
                elif round(weight) < -2:
                    r_weight = -2
                else:
                    r_weight = round(weight)
                classif = self.weight_dict[r_weight]
            vid['bias'] = self.bias
            vid['weight'] = weight
            vid['classifs'] = classifs_flat
            vid['classif'] = classif
            vid['pick'] = False
            vid['round'] = self.itteration
            vid['rec_from'] = self.origin
            results.append(vid)
        return results

    def get_mean_weight(self, classifs):
        """
        Gets mean weight of classifs list

        @param: list of classifications
        @return: mean weight
        """
        weights = []
        for classif in classifs:
            if classif == "MissingLinkMedia":
                continue
            w = self.classif_dict[classif]
            weights.append(w)
        return np.mean(weights)

    def pick(self, videos):
        """
        Routes to helper method

        @param: list of classified videos
        @return: pick
        """
        if self.bias == 'Neutral':
            pick = self.pick_neutral(videos)
        elif self.bias == 'Right':
            pick = self.pick_right(videos)
        elif self.bias == 'Left':
            pick = self.pick_left(videos)
        else:
            raise ValueError(
                "Bias parameter must be of value 'Right', 'Left' or 'Neutral'.")
        pick['pick'] = True
        self.origin = pick['video_id']
        return pick

    def pick_right(self, videos):
        """
        Selects video associated with most right wing channel

        @param: list of classified videos
        @return: pick
        """
        pick = 0
        index = 0
        while index < len(videos):
            if videos[pick]['weight'] < videos[index]['weight']:
                pick = index
            index += 1
        return videos[pick]

    def pick_left(self, videos):
        """
        Selects video associated with most left wing channel

        @param: list of classified videos
        @return: pick
        """
        pick = 0
        index = 0
        while index < len(videos):
            if videos[pick]['weight'] > videos[index]['weight']:
                pick = index
            index += 1
        return videos[pick]

    def pick_neutral(self, videos):
        """
        Picks the first video

        @param: list of classified videos
        @return: pick
        """
        return videos[0]


def run_bot(bot):
    index = 0
    topics = ['Election', 'Jack Dorsey',
              'Lil Wayne', 'Moderna', 'Gavin Newsom']
    recommendations_set = []
    while index < 5:
        starter = Starter(topics[index], '/m/05qt0', 10)
        start = starter.find_video()
        bot.set_start(start)
        recommendations = bot.walk()
        recommendations = [dict(item, topic_n=index, topic=topics[index])
                           for item in recommendations]
        recommendations_set += recommendations
        index += 1
        time.sleep(10)
    return recommendations_set


def main():
    political_bot_left = Bot('Left', 4, 10)

    political_bot_right = Bot('Right', 4, 10)

    political_bot_neutral = Bot('Neutral', 4, 10)

    recomms_neutral = run_bot(political_bot_neutral)

    recomms_left = run_bot(political_bot_left)

    recomms_right = run_bot(political_bot_right)

    df_recomms_left = pd.DataFrame(recomms_left)
    df_recomms_right = pd.DataFrame(recomms_right)
    df_recomms_neutral = pd.DataFrame(recomms_neutral)

    # must change location before running
    df_recomms_left.to_csv(
        r'/Users/danielcovelli/Desktop/ISF190/data/left_set_11.csv', index=False, header=True)
    df_recomms_right.to_csv(
        r'/Users/danielcovelli/Desktop/ISF190/data/right_set_11.csv', index=False, header=True)
    df_recomms_neutral.to_csv(
        r'/Users/danielcovelli/Desktop/ISF190/data/neutral_set_11.csv', index=False, header=True)


if __name__ == "__main__":
    main()
